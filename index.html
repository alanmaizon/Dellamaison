        function updateMoveHistory() {
            moveHistoryElement.innerHTML = 'Move History:<br>';
            moveHistory.forEach((move, index) => {
                moveHistoryElement.innerHTML += `${index + 1}. ${move.piece} from (${move.fromRow}, ${move.fromCol}) to (${move.toRow}, ${move.toCol})<br>`;
            });
        }

        function updateTimer() {
            if (isPlayerTurn) {
                whiteTime--;
                whiteTimerElement.textContent = `White: ${formatTime(whiteTime)}`;
                if (whiteTime === 0) {
                    clearInterval(timerInterval);
                    alert('Black wins on time!');
                }
            } else {
                blackTime--;
                blackTimerElement.textContent = `Black: ${formatTime(blackTime)}`;
                if (blackTime === 0) {
                    clearInterval(timerInterval);
                    alert('White wins on time!');
                }
            }
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
        }

        undoButton.addEventListener('click', () => {
            if (moveHistory.length > 0) {
                const lastMove = moveHistory.pop();
                board[lastMove.fromRow][lastMove.fromCol] = lastMove.piece;
                board[lastMove.toRow][lastMove.toCol] = lastMove.captured;
                enPassant = lastMove.enPassantTarget;
                castlingRights = lastMove.castlingRights;
                isPlayerTurn = !isPlayerTurn;
                updateMoveHistory();
                updateGameStatus();
                renderBoard();
            }
        });

        renderBoard();
        timerInterval = setInterval(updateTimer, 1000);
    });
</script>